1、BU-61580有“缓冲”和“透明”2种存储模式，前者使用BU-61580内部4Kx16bit缓冲区，后者使用外部RAM作为数据缓冲区，最大可达64Kx16bit。 
2、BU-61580的缓冲模式又分“8-bit”，和“16-bit”2种结构。分别称为“8-bit缓冲模式”与“16-bit缓冲模式”。 
3、BU-61580读写模式有“0等待”与“非0等待”2种，与上述缓冲模式组合成4种工作模式：（1）8-bit缓冲、0等待；（2）8-bit缓冲、非0等待；（3）16-bit缓冲、0等待；（4）16-bit缓冲、非0等待。 
4、所谓“0等待”就是主控CPU（MCU、ARM、DSP等）存贮61580内部缓冲区时不用插入等待周期，在发出读/写命令（Select、STRBD、RD/WR#）后，61580的数据准备好信号（READYD#）立即有效（为低），因此主控CPU可以不用判断READYD#信号。 
要注意一点的是，对于读操作来说，这时D0-D15代表的不是本次读操作地址对应单元的内容，而是上次读操作地址对应单元的内容，这是由61580内部逻辑决定的（即所谓的“输出数据延时”）。 
这样，对于连续读操作，第一次读数据无效（空操作），第二次读到的是第一次地址的内容，第三次读到的是第二次地址的内容，依次类推；如果是随机读操作，两次读相同地址即可，第二次数据有效。 
5、有一个特例就是“中断状态寄存器”需要读3次才行：第一次读，地址为ISR（0x06)，数据无效；第二次读，地址任意（如0x00)，数据无效；第三次读，除ISR外的任意地址（如0x00），数据有效。 
6、在“0等待”模式，SELECT#和STRBD#负脉冲宽度必须>20ns。例如，主控CPU为DSP6203B时，主频为250MHz，其CPU时钟周期P=4ns，EMIF片选信号CEn脉冲宽度=7xP=28ns,但ARE#、AWE#脉宽只有3xP=12ns，因此，应用时只能用CEn驱动SELECT#和STRBD#。 
如果使用主频更高的DSP，如64xx系列，上述脉宽条件再也无法满足，就必须使用“非0等待”模式，在读/写周期中插入相应的等待周期了。 
7、“非0等待”就是高速主控CPU（如64xx系列DSP）异步存取61580时，每个读/写周期插入若干个等待周期，直到READYD#信号有效为止。注意61580的READYD#是参考Intel80286 CPU的专用芯片82284设计的，可与82284的ARDY#直接连接，经其同步处理后送给80286的READY#；但如用在TI的DSP中，必须做相应处理才能与其ARDY相连，即：ARDY=CEn or(not READYD#)。 
8、BU-61580是5V供电，接口电平为TTL，与3.3V供电（LVTTL）的DSP和FPGA连接时，由于LVTTL向上兼容TTL，DSP/FPGA送给61580的地址、控制信号可直接连接，但61580送给DSP/FPGA的状态信号以及双向数据总线必须经过电平转换（例如使用TI的SN74LVT245），否则会形成电流倒灌损坏芯片。 
